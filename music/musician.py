"""Domain classes and functions related to the concept of musician
"""


from util import utility
from music.enums import Vocals, Instrument
import json


class Musician:
    """The class describing the concept of musician.
    It is assumed that a musician is sufficiently described by their
    name and whether they are a solo musician or a member of a band.

    This class illustrates some important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - __dict__ attribute of all objects
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, name, is_band_member=True):
        self.name = name
        self.is_band_member = is_band_member
        # self.__n = 'lll'                                    # 'private' field
        # self._m = 'mmm'
        # self.__immutable_property = 'I am immutable'

    def __str__(self):
        band_name_str = f'(band member)' if self.is_band_member else f'(solo musician)'
        return f'{self.name} {band_name_str}'

    def __eq__(self, other):
        t = isinstance(other, Musician)
        n = self.name == other.name if t else False
        b = self.is_band_member == other.is_band_member if t else False
        return t and n and b

    # Properties: 'private' fields/attributes:
    #   @property
    #   def <attr>(self):
    #       """ The docstring for <attr> must go here."""
    #       return self.__<attr>
    #   @<attr>.setter
    #   def <attr>(self, <attr>):
    #       self.__<attr> = <attr> if ... else ...
    #   @<attr>.deleter
    #   def <attr>(self, <attr>):
    #       del self.__<attr>

    # Properties allow programmers to create methods that behave like attributes.
    # With properties, one can change how they compute the target attribute whenever they need to do so.
    # A more detailed explanation: https://realpython.com/python-property/.
    # In general, avoid turning attributes that donâ€™t require extra processing into properties.
    # Using properties in those situations can make the code unnecessarily verbose, confusing and slower
    # than code based on regular attributes.

    # Make name a property (after setting up __init__(), __str__(), __eq__(), methods,...)

    # Run setters and getters in the debugger

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name if isinstance(name, str) else 'unknown'

    # Add an immutable property (no setter for it)
    # @property
    # def immutable_property(self):
    # return self.__immutable_property

    def play(self, song_title, *args, **kwargs):
        """Assumes that song_title, *args (expressions of gratitude) and kwargs.values() (messages) are strings.
        Prints song_title, rhythm counts, expressions of gratitude and messages. A call example:
            <musician>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        Convention: if rhythm count is provided, it is passed as rhythm_count='...' and is the first kwarg.
        """

        rhythm_count = ' - ' + kwargs['rhythm_count'] + ' - ' if 'rhythm_count' in kwargs.keys() else ''
        g = ' '.join([g for g in args]) if args else ''
        if 'rhythm_count' in kwargs.keys():
            del kwargs['rhythm_count']              # if not deleted, it will appear in m (see the next line)
        m = ' '.join([v for v in kwargs.values()]) if kwargs else ''
        return f'{self.name} playing {song_title}{rhythm_count}... (playing) ... {g} {m}'

    def play_song(self, song_title, *args, **kwargs):
        """Demonstrates calling another method from the same class (self.<method>(...) as a mandatory syntax).
        """

        return self.play(song_title, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, musician_string):
        """Inverted __str__() method.
        Assumes that musician_string is in the format generated by __str__().
        """

        # band_name_str = f'(band member)' if self.is_band_member else f'(solo musician)'
        # return f'{self.name} {band_name_str}'
        n = musician_string.split('(')[0].rstrip()
        b = musician_string.split('(')[1].startswith('b')
        return cls(n, b)


class MusicianEncoder(json.JSONEncoder):
    """JSON encoder for Musician objects (cls= parameter in json.dumps()).
    """

    def default(self, musician):
        # recommendation: always use double quotes with JSON

        pass
        # can simply return musician_py_to_json(musician), to avoid code duplication


def musician_py_to_json(musician):
    """JSON encoder for Musician objects (default= parameter in json.dumps()).
    """

    # recommendation: always use double quotes with JSON


def musician_json_to_py(musician_json):
    """JSON decoder for Musician objects (object_hook= parameter in json.loads()).
    """


class Singer(Musician):
    """The class describing the concept of singer.
    It is assumed that a singer is sufficiently described as a Musician,
    with the addition of whether they are a lead or a background singer.

    Useful link (related to inheritance in Python):
    https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs/3394902#3394902 (calling super() in constructors)
    """

    # # Version 1 - no multiple inheritance
    # def __init__(self, name, vocals, is_band_member=True, ):
    #     super().__init__(name, is_band_member)
    #     self.vocals = vocals if isinstance(vocals, Vocals) else None

    # Version 2 - with multiple inheritance
    def __init__(self, vocals=Vocals.LEAD_VOCALS, **kwargs):
        super().__init__(**kwargs)
        self.vocals = vocals if isinstance(vocals, Vocals) else None

    def __str__(self):
        return super().__str__() + f'\n{str(self.vocals.name).lower().replace("_", " ")}'

    def __eq__(self, other):
        return isinstance(other, Singer) and (super().__eq__(other)) and (self.vocals == other.vocals)

    def play(self, song_title, *args, **kwargs):
        """Overrides the play() method from superclass.
        In addition to printing song_title, expressions of gratitude and messages,
        it also prints an additional message in the end.
        A call example:
            <singer>.play(song_title, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        return super().play(song_title, *args, **kwargs) + '\nYeah!'


class Songwriter(Musician):
    """The class describing the concept of songwriter.
    It is assumed that a songwriter is sufficiently described as a musician
    who writes songs and plays an instrument.
    """

    # # Version 1 - no multiple inheritance
    # def __init__(self, name, instrument, is_band_member=True):
    #     super().__init__(name, is_band_member)
    #     self.instrument = instrument if isinstance(instrument, Instrument) else None

    # Version 2 - with multiple inheritance
    def __init__(self, instrument=Instrument.RHYTHM_GUITAR, **kwargs):
        super().__init__(**kwargs)
        self.instrument = instrument
        self.writes_songs = True

    def __str__(self):
        return super().__str__() + f'\n{str(self.instrument.name).lower().replace("_", " ")}'

    def __eq__(self, other):
        return isinstance(other, Songwriter) and super().__eq__(other) and (self.instrument == other.instrument)

    def what_do_you_do(self):
        """Just a simple method to describe the concept of songwriter.
        """

        return f'I am {self.name} and I write songs.'


class SingerSongwriter(Singer, Songwriter):
    """The class describing the concept of singer-songwriter.
    It is assumed that a singer-songwriter is sufficiently described as a Singer who is simultaneously a Songwriter.

    Useful links :
    https://stackoverflow.com/a/50465583/1899061 (designing classes (i.e. their __init__() methods) for multiple inh.)
    https://stackoverflow.com/a/533675/1899061 (mixins explained, and what good they are in multiple inheritance)
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)


if __name__ == "__main__":

    # from testdata.musicians import *

    # Print objects
    paul = Musician('Paul McCartney', is_band_member=False)
    print(paul)

    # Run setters and getters in the debugger

    paul.is_band_member = True
    paul.name = 'Paul McC'
    print(paul)
    print()

    # Compare objects
    print(paul == Musician('Paul McC'))
    print()

    # Access data fields/attributes (instance variables),
    # including 'private' ones (<object>._Musician__n), 'protected' ones (<object>._Musician__m) and
    # immutable ones (<object>.immutable_property)
    # print(paul._Musician__n)
    # print(paul._m)
    # print(paul.immutable_property)
    print()

    # Add new data fields (instance variables)
    #   1. <object>.<new_attr> = <value>
    #   2. <object>.__setattr__('<new_attr>', <value>)      # counterpart: <object>.__getattribute__('<attr>')
    #   3. setattr(<object>, '<new_attr>', <value>))        # counterpart: getattr(<object>, '<attr>')
    # paul.year = 1942
    # print(paul.year)
    print()

    # Calling methods
    print(paul.play('I Saw Her Standing There', 'Thank You!',
                    rhythm_count='One, two, three, four!', love='We Love You!'))
    print(paul.play('I Saw Her Standing There', 'Thank You!',
                    love='We Love You!'))
    print(paul.play_song('I Saw Her Standing There', 'Thank You!',
                    love='We Love You!'))
    print()

    # Demonstrate object data fields and methods in Python Console for some built-in classes (boolean, int, object,...)
    # - True + 1
    # - True.__int__()
    # - (1).__class__.__name__
    # - (1).__class__
    # - o.__dir__()
    # - o.__dir__
    # - o.__dict__
    #
    # print(True + 1)
    # print(True.__int__())
    # print((1).__class__)
    # print((1).__class__.__name__)
    # print((1).__dir__())
    # print(object.__dict__)
    # print()

    # Demonstrate object data fields and methods for Musician objects
    print(paul.__dict__)
    print(paul.__class__)
    print(paul.__class__.__name__)
    print()

    # Demonstrate @classmethod (from_str())
    paul_str = str(paul)
    print(paul == Musician.from_str(paul_str))
    print()

    # Demonstrate inheritance
    # object class (like the Object class in Java; all classes inherit from object
    #   try, e.g., list.__mro__ in the console)
    #   object class defines object.__eq__(self, other) etc.
    #   object.__ne__(self, other), the inverse of object.__eq__(self, other),
    #   is provided by Python automatically once object.__eq__(self, other) is implemented

    # # Version 1 - no multiple inheritance
    # paul = Singer('Paul McCartney', Vocals.LEAD_VOCALS)
    # print(paul)
    # print(Singer.__mro__)
    # print(paul == Singer('Paul McCartney', Vocals.LEAD_VOCALS))
    # print()
    # john = Songwriter('John Lennon', Instrument.RHYTHM_GUITAR)
    # print(john)
    # print(john == Songwriter('John Lennon', Instrument.RHYTHM_GUITAR))
    # print(john.what_do_you_do())
    # print()

    # Version 2 - with multiple inheritance
    paul = Singer(name = 'Paul McCartney', vocals=Vocals.LEAD_VOCALS, is_band_member=True)
    print(paul)
    print(paul == Singer(name = 'Paul McCartney', vocals=Vocals.LEAD_VOCALS, is_band_member=True))
    print()
    john = Songwriter(name = 'John Lennon', instrument=Instrument.RHYTHM_GUITAR, is_band_member=True)
    print(john)
    print(john == Songwriter(name = 'John Lennon', instrument=Instrument.RHYTHM_GUITAR, is_band_member=True))
    print()

    # Demonstrate method overriding
    print(paul.play('I Saw Her Standing There', 'Thank You!',
                    rhythm_count='One, two, three, four!', love='We Love You!'))
    print()

    # Demonstrate multiple inheritance and MRO.
    # Make sure to read this first: https://stackoverflow.com/a/50465583/1899061 (especially Scenario 3).
    print(SingerSongwriter.__mro__)
    bob = SingerSongwriter(name='Bob Dylan', vocals=Vocals.LEAD_VOCALS,
                           instrument=Instrument.RHYTHM_GUITAR, is_band_member=False)
    print(bob)
    print()
    print(bob == SingerSongwriter(name='Bob Dylan', vocals=Vocals.LEAD_VOCALS,
                                  instrument=Instrument.RHYTHM_GUITAR, is_band_member=False))
    print()

    # Demonstrate JSON encoding/decoding of simple data types.
    # Refer to https://docs.python.org/3.3/library/json.html#encoders-and-decoders for details.
    print()

    # Demonstrate JSON encoding/decoding of Musician objects
    # Single object
    print()

    # List of objects
    print()

